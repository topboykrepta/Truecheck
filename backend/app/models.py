from __future__ import annotations

import enum
from datetime import datetime
from typing import Optional

from sqlmodel import SQLModel, Field


class InputType(str, enum.Enum):
    text = "text"
    image = "image"
    audio = "audio"


class ReportStatus(str, enum.Enum):
    queued = "queued"
    running = "running"
    complete = "complete"
    failed = "failed"


class Verdict(str, enum.Enum):
    true = "True"
    false = "False"
    misleading = "Misleading"
    unverifiable = "Unverifiable"
    ai_generated = "AI-Generated"
    mixed = "Mixed"


class SourceCredibility(str, enum.Enum):
    trusted = "Trusted"
    neutral = "Neutral"
    unknown = "Unknown"
    low = "Low credibility"


class Report(SQLModel, table=True):
    id: str = Field(primary_key=True)
    created_at: datetime = Field(default_factory=datetime.utcnow, index=True)
    updated_at: datetime = Field(default_factory=datetime.utcnow, index=True)

    input_type: InputType
    original_filename: Optional[str] = None
    input_text: Optional[str] = None
    storage_path: Optional[str] = None

    status: ReportStatus = Field(default=ReportStatus.queued)
    error_message: Optional[str] = None

    verdict: Optional[Verdict] = None
    confidence: Optional[int] = None
    explanation: Optional[str] = None

    ai_likelihood: Optional[int] = None


class Claim(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    report_id: str = Field(index=True)
    claim_text: str
    status: str  # Supported/Contradicted/Unclear
    confidence: int

    # Per-claim explanation generated by Gemini (or rules-based fallback).
    rationale: Optional[str] = None

    # Snapshot of the evidence list and citation indices used to produce `rationale`.
    # Stored as a JSON string: {"evidence": [...], "citations": [...]}.
    reasoning_json: Optional[str] = None


class EvidenceItem(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    report_id: str = Field(index=True)
    claim_id: Optional[int] = Field(default=None, index=True)

    kind: str  # web_extract/image_match

    url: str
    publisher: Optional[str] = None
    published_date: Optional[str] = None

    title: Optional[str] = None
    snippet: Optional[str] = None

    thumbnail_url: Optional[str] = None
    credibility: Optional[SourceCredibility] = None


class OriginTrace(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    report_id: str = Field(index=True)

    likely_origin_url: Optional[str] = None
    earliest_appearance: Optional[str] = None
    timeline_json: Optional[str] = None  # stored as JSON string


class AuditEvent(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    report_id: str = Field(index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow, index=True)

    event_type: str
    details_json: str


class SearchCache(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    created_at: datetime = Field(default_factory=datetime.utcnow, index=True)
    expires_at: datetime = Field(index=True)

    kind: str = Field(index=True)  # web|image|gdelt
    query: str = Field(index=True)
    response_json: str
